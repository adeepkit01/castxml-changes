32a33,34
> from pygccxml.declarations import type_traits_classes
> from pygccxml.declarations import traits_impl_details
34a37,38
> from pygccxml.declarations import calldef_members
> from pygccxml.declarations import calldef_types
40a45
> from pygccxml.utils import find_xml_generator
111c116
<     decl = pygccxml.declarations.type_traits.impl_details.find_value_type(global_ns, declaration_name)
---
>     decl = pygccxml.declarations.traits_impl_details.impl_details.find_value_type(global_ns, declaration_name)
137,138c142,143
<         if hasattr(wrapper, "gccxml_definition"):
<             definition = wrapper.gccxml_definition
---
>         if hasattr(wrapper, "castxml_definition"):
>             definition = wrapper.castxml_definition
141c146
<                 definition = wrapper.main_wrapper.gccxml_definition
---
>                 definition = wrapper.main_wrapper.castxml_definition
350a356,358
>         if not file_name:
>             return {}, {}
> 
464c472
<         :param pygccxml_definition: gccxml definition object
---
>         :param pygccxml_definition: castxml definition object
508c516
<         self.gccxml_config = None
---
>         self.castxml_config = None
528c536
<         Add a function to be called right before converting a gccxml
---
>         Add a function to be called right before converting a castxml
560c568
<         Add a function to be called right after converting a gccxml definition
---
>         Add a function to be called right after converting a castxml definition
586c594
<               pygen_sink=None, pygen_classifier=None, gccxml_options=None):
---
>               pygen_sink=None, pygen_classifier=None, castxml_options=None):
599c607
<                         pygen_classifier, gccxml_options)
---
>                         pygen_classifier, castxml_options)
608c616
<                    gccxml_options=None):
---
>                    castxml_options=None):
622c630
<         :param include_paths: (deprecated, use the parameter gccxml_options) list of include paths
---
>         :param include_paths: (deprecated, use the parameter castxml_options) list of include paths
640c648
<            not require pygccxml or gccxml to run, only PyBindGen to be
---
>            not require pygccxml or castxml to run, only PyBindGen to be
652c660
<         :param gccxml_options: extra options to pass into the
---
>         :param castxml_options: extra options to pass into the
656c664
<         :type gccxml_options: dict
---
>         :type castxml_options: dict
685,687c693,695
<         if gccxml_options is None:
<             gccxml_options = {}
< 
---
>         if castxml_options is None:
>             castxml_options = {}
>         generator_path, generator_name = find_xml_generator()
690c698
<             warnings.warn("Parameter include_paths is deprecated, use gccxml_options instead", DeprecationWarning,
---
>             warnings.warn("Parameter include_paths is deprecated, use castxml_options instead", DeprecationWarning,
692c700
<             self.gccxml_config = parser.gccxml_configuration_t(include_paths=include_paths, **gccxml_options)
---
>             self.castxml_config = parser.xml_generator_configuration_t(include_paths=include_paths, xml_generator_path=generator_path, xml_generator=generator_name, castxml_epic_version=1, **castxml_options)
694c702
<             self.gccxml_config = parser.gccxml_configuration_t(**gccxml_options)
---
>             self.castxml_config = parser.xml_generator_configuration_t(xml_generator_path=generator_path, xml_generator=generator_name, castxml_epic_version=1, **castxml_options)
696c704
<         self.declarations = parser.parse(header_files, self.gccxml_config)
---
>         self.declarations = parser.parse(header_files, self.castxml_config)
804c812
<             if isinstance(class_wrapper.gccxml_definition, class_declaration_t):
---
>             if isinstance(class_wrapper.castxml_definition, class_declaration_t):
810c818
<             pygen_sink =  self._get_pygen_sink_for_definition(class_wrapper.gccxml_definition)
---
>             pygen_sink =  self._get_pygen_sink_for_definition(class_wrapper.castxml_definition)
837c845
<             if isinstance(class_wrapper.gccxml_definition, class_declaration_t):
---
>             if isinstance(class_wrapper.castxml_definition, class_declaration_t):
845c853
<             pygen_sink =  self._get_pygen_sink_for_definition(class_wrapper.gccxml_definition)
---
>             pygen_sink =  self._get_pygen_sink_for_definition(class_wrapper.castxml_definition)
853c861
<             self._scan_class_methods(class_wrapper.gccxml_definition, class_wrapper, pygen_sink)
---
>             self._scan_class_methods(class_wrapper.castxml_definition, class_wrapper, pygen_sink)
936c944
<             if isinstance(member, calldef.destructor_t):
---
>             if isinstance(member, calldef_members.destructor_t):
941c949
<             if isinstance(member, calldef.destructor_t):
---
>             if isinstance(member, calldef_members.destructor_t):
996c1004
<             enums = module_namespace.enums(function=self.location_filter,
---
>             enums = module_namespace.enumerations(function=self.location_filter,
1000c1008
<             for enum in outer_class.gccxml_definition.enums(function=self.location_filter,
---
>             for enum in outer_class.castxml_definition.enumerations(function=self.location_filter,
1002c1010
<                 if outer_class.gccxml_definition.find_out_member_access_type(enum) != 'public':
---
>                 if outer_class.castxml_definition.find_out_member_access_type(enum) != 'public':
1049c1057
<             for cls in outer_class.gccxml_definition.classes(function=self.location_filter,
---
>             for cls in outer_class.castxml_definition.classes(function=self.location_filter,
1051c1059
<                 if outer_class.gccxml_definition.find_out_member_access_type(cls) != 'public':
---
>                 if outer_class.castxml_definition.find_out_member_access_type(cls) != 'public':
1057c1065
<             for typedef in outer_class.gccxml_definition.typedefs(function=self.location_filter,
---
>             for typedef in outer_class.castxml_definition.typedefs(function=self.location_filter,
1059c1067
<                 if outer_class.gccxml_definition.find_out_member_access_type(typedef) != 'public':
---
>                 if outer_class.castxml_definition.find_out_member_access_type(typedef) != 'public':
1113c1121
<                     typedef_type = type_traits.remove_declarated(typedef.type)
---
>                     typedef_type = type_traits.remove_declarated(typedef.decl_type)
1288c1296
<             class_wrapper.gccxml_definition = cls
---
>             class_wrapper.castxml_definition = cls
1340c1348
<                 type_from_name = normalize_name(str(alias.type))
---
>                 type_from_name = normalize_name(str(alias.decl_type))
1353,1354c1361,1362
<                 if isinstance(alias.type, cpptypes.declarated_t):
<                     cls = alias.type.declaration
---
>                 if isinstance(alias.decl_type, cpptypes.declarated_t):
>                     cls = alias.decl_type.declaration
1380c1388
<                         class_wrapper.gccxml_definition = cls
---
>                         class_wrapper.castxml_definition = cls
1513,1514c1521,1541
< 
<         element_type = traits.element_type(definition)
---
>         #print ("*********************", templates.args(traits.class_declaration(definition).name))
>         try:
>           element_type = traits.element_type(definition)
>         except RuntimeError:
>           value_type_str = templates.args(traits.class_declaration(definition).name)[traits.element_type_index]
>           try:
>             has_space_pointer = value_type_str.endswith(' *')
>             if has_space_pointer:
>               value_type_str = value_type_str[:-2]
>             element_type = find_declaration_from_name (traits.class_declaration(definition).top_parent, value_type_str)
>             if None is element_type:
>               raise RuntimeError(
>                         "Unable to find out %s '%s' key\\value type." %
>                         (traits.name(), traits.class_declaration(definition).decl_string))
>           except RuntimeError:
>             if value_type_str == "unsigned short":
>               element_type = find_declaration_from_name (traits.class_declaration(definition).top_parent, "short unsigned int")
>             else:
>               raise RuntimeError(
>                         "Unable to find out %s '%s' key\\value type." %
>                         (traits.name(), traits.class_declaration(definition).decl_string))
1562,1563c1589,1590
<             if isinstance(member, calldef.member_function_t):
<                 if member.virtuality != calldef.VIRTUALITY_TYPES.NOT_VIRTUAL:
---
>             if isinstance(member, calldef_members.member_function_t):
>                 if member.virtuality != calldef_types.VIRTUALITY_TYPES.NOT_VIRTUAL:
1582c1609
<                     and type_traits.is_convertible(cls, argument_types[1]):
---
>                     and type_traits_classes.is_convertible(cls, argument_types[1]):
1590,1591c1617,1618
<                     and type_traits.is_convertible(cls, argument_types[0]) \
<                     and type_traits.is_convertible(cls, argument_types[1]):
---
>                     and type_traits_classes.is_convertible(cls, argument_types[0]) \
>                     and type_traits_classes.is_convertible(cls, argument_types[1]):
1607c1634
<             if not type_traits.is_convertible(cls, argument_types[0]):
---
>             if not type_traits_classes.is_convertible(cls, argument_types[0]):
1673c1700
<             _handle_operator(op, [arg.type for arg in op.arguments])
---
>             _handle_operator(op, [arg.decl_type for arg in op.arguments])
1680c1707
<             arg_types = [arg.type for arg in op.arguments]
---
>             arg_types = [arg.decl_type for arg in op.arguments]
1695c1722
<             if isinstance(member, calldef.member_function_t):
---
>             if isinstance(member, calldef_members.member_function_t):
1699c1726
<             elif isinstance(member, calldef.constructor_t):
---
>             elif isinstance(member, calldef_members.constructor_t):
1707c1734
<                     traits = ctypeparser.TypeTraits(normalize_name(member.arguments[0].type.partial_decl_string))
---
>                     traits = ctypeparser.TypeTraits(normalize_name(member.arguments[0].decl_type.partial_decl_string))
1731,1733c1758,1760
<             if isinstance(member, (calldef.member_function_t, calldef.member_operator_t)):
<                 is_virtual = (member.virtuality != calldef.VIRTUALITY_TYPES.NOT_VIRTUAL)
<                 pure_virtual = (member.virtuality == calldef.VIRTUALITY_TYPES.PURE_VIRTUAL)
---
>             if isinstance(member, (calldef_members.member_function_t, calldef_members.member_operator_t)):
>                 is_virtual = (member.virtuality != calldef_types.VIRTUALITY_TYPES.NOT_VIRTUAL)
>                 pure_virtual = (member.virtuality == calldef_types.VIRTUALITY_TYPES.PURE_VIRTUAL)
1739c1766
<                             and templates.is_instantiation(member.demangled_name):
---
>                             and templates.is_instantiation(str(member)):
1753c1780
<                 if isinstance(member, calldef.member_operator_t):
---
>                 if isinstance(member, calldef_members.member_operator_t):
1768c1795
<                     argument_specs.append(self.type_registry.lookup_parameter(arg.type, arg.name,
---
>                     argument_specs.append(self.type_registry.lookup_parameter(arg.decl_type, arg.name,
1779,1780c1806,1807
<                 if templates.is_instantiation(member.demangled_name):
<                     template_parameters = templates.args(member.demangled_name)
---
>                 if templates.is_instantiation(str(member)):
>                     template_parameters = templates.args(str(member))
1867c1894
<                     method_wrapper.gccxml_definition = member
---
>                     method_wrapper.castxml_definition = member
1890c1917
<             elif isinstance(member, calldef.constructor_t):
---
>             elif isinstance(member, calldef_members.constructor_t):
1899c1926
<                     argument_specs.append(self.type_registry.lookup_parameter(arg.type, arg.name,
---
>                     argument_specs.append(self.type_registry.lookup_parameter(arg.decl_type, arg.name,
1931c1958
<                                                % (arg.type.partial_decl_string, arg.name, member, ex),
---
>                                                % (arg.decl_type.partial_decl_string, arg.name, member, ex),
1940c1967
<                 constructor_wrapper.gccxml_definition = member
---
>                 constructor_wrapper.castxml_definition = member
1961c1988
<                 real_type = type_traits.remove_declarated(member.type)
---
>                 real_type = type_traits.remove_declarated(member.decl_type)
1970c1997
<                 return_type_spec = self.type_registry.lookup_return(member.type, global_annotations)
---
>                 return_type_spec = self.type_registry.lookup_return(member.decl_type, global_annotations)
1978c2005
<                                         type_traits.is_const(member.type)))
---
>                                         type_traits.is_const(member.decl_type)))
1982c2009
<                                         type_traits.is_const(member.type)))
---
>                                         type_traits.is_const(member.decl_type)))
1989c2016
<                                            % (member.type.partial_decl_string, member, ex),
---
>                                            % (member.decl_type.partial_decl_string, member, ex),
1995c2022
<                                                        is_const=type_traits.is_const(member.type))
---
>                                                        is_const=type_traits.is_const(member.decl_type))
1998c2025
<                                                          is_const=type_traits.is_const(member.type))
---
>                                                          is_const=type_traits.is_const(member.decl_type))
2000c2027
<             elif isinstance(member, calldef.destructor_t):
---
>             elif isinstance(member, calldef_members.destructor_t):
2006c2033
<             if type_traits.has_trivial_constructor(cls):
---
>             if type_traits_classes.has_trivial_constructor(cls):
2012c2039
<                 has_copy_constructor = type_traits.has_copy_constructor(cls)
---
>                 has_copy_constructor = type_traits_classes.has_copy_constructor(cls)
2151c2178
<                         and isinstance(arg.type, cpptypes.pointer_t):
---
>                         and isinstance(arg.decl_type, cpptypes.pointer_t):
2154c2181
<                 spec = self.type_registry.lookup_parameter(arg.type, arg.name,
---
>                 spec = self.type_registry.lookup_parameter(arg.decl_type, arg.name,
2162c2189
<                                            % (arg.type.partial_decl_string, arg.name, fun, ex),
---
>                                            % (arg.decl_type.partial_decl_string, arg.name, fun, ex),
2168c2195
<                                            % (arg.type.partial_decl_string, arg.name, fun, ex),
---
>                                            % (arg.decl_type.partial_decl_string, arg.name, fun, ex),
2193c2220
<                     function_wrapper.gccxml_definition = fun
---
>                     function_wrapper.castxml_definition = fun
2211c2238
<                     function_wrapper.gccxml_definition = fun
---
>                     function_wrapper.castxml_definition = fun
2215,2216c2242,2243
<             if templates.is_instantiation(fun.demangled_name):
<                 template_parameters = templates.args(fun.demangled_name)
---
>             if templates.is_instantiation(str(fun)):
>                 template_parameters = templates.args(str(fun))
2249c2276
<                 func_wrapper.gccxml_definition = fun
---
>                 func_wrapper.castxml_definition = fun
